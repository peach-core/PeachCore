# 内存空间

## 1. riscv 页表机制

## 2. 内存空间模型  
操作系统的内存空间有两种模型:
1. 每个进程分配一个页表, 包含内核和用户空间, 但是设置访问权限, 通过权限隔离实现逻辑隔离.
2. 每个进程分配一个页表, 只包含用户空间, 所有进程共用一个内核空间的页表. `Trap` 进内核后, 切换至内核页表, 实现内核和用户空间的完全隔离.

方法1的好处是: 仅在任务切换时需要刷新页表及缓存, 普通的系统调用无需切换页表. 在内核空间访问用户空间时仅需要设置一个 `sstatus` 位即可.
方法2的好处是: 对用户空间和内核空间实现完全隔离, 从而能防止 幽灵, 熔断等 因为缓存导致的 漏洞.

`rCore` 采用了第二种设计, 此时, 在 `Trap` 发生时, 特权模式发生切换, `pc` 切换到 `__trap_entry`, 但 `sp` 还在用户栈, `内存空间` 还在用户空间. 而 `riscv` 只提供了一个 `sscratch`, 那么我们只能将 `satp` 保存在内存上.

此时会出现一些问题, 我们后面展开来讲.

### 内核空间
内核空间对所有物理内存有访问权限, 因此可以简单的对所有物理内存建立直接映射.

#### TODO
- [ ] 可以通过 `riscv-64 sv39` 的 `1GB, 2MB` 的大页表机制实现内核空间的映射, 可以比使用 `2KB` 的页表节省不少空间. 即对 `MemoryArea` 实现一个多态, 实现三种大小页的管理.

### 用户空间
根据 `elf` 文件按需分配, 每个进程一个单独的用户页表.

### 用户空间与内核空间交互
采用 方案1 时, 我们可以使用同一个页表从内核访问用户空间, 但使用 方案2 时, 需要采用比较特殊的方式:
在内核态获取用户页表(内核对所有物理内存有访问权, 包括页表本身), 通过手动查找某个用户空间虚拟地址对应的物理地址来访问用户数据.

### Trap 时出现的问题
由于 sv39 也拥有 512TB 的空间, 内核态低位地址被用于物理地址直接映射, 用户态地址也从低位开始使用, 因此, 高位地址可以被用于其他用途. 下面的 `TRAMPOLINE Page` `TrapContext Page` 分别保存在 **最高页和次高页**.

#### 问题1. __trap_entry 的权限问题
我们需要再 `__trap_entry` 代码中进行空间切换, 那么切换空间的 `csrw satp, xxx` 发生后, `pc` 指向下一条指令的虚拟地址, 但该指令前后 `内存空间` 已经发生切换, `pc` 对应的物理地址可能不存在.

**解决方案**是, 将 `__trap_entry` 写到单独的物理页上, 并约定在 用户/内核空间, 该物理页对应的虚拟页号相同(`TRAMPOLINE Page`), 同时, 位于用户空间和内核空间的 `TRAMPOLINE Page` 都必须置 `PTE::U` 为 **0**, 因为 `trap` 过程完全发生在内核态.

#### 问题2. `TrapContext` 要在用户空间访问
原先我们将 `TrapContext` 保存在内核栈底, 但此时, 我们在用户空间无法访问内核栈. 因此, 我们选择使用一个固定虚拟地址的页框(`TrapContext Page`), 专门用于保存 `TrapContext`, 该页位于用户空间, 保存内存空间切换的必要信息, 如 保存寄存器上下文, 用户态的 `csr(sepc, sstatus)`, `kernel_stap`, `kernel_sp`, `trap_handle`(见*问题3*)

此时, `csr sscratch` 寄存器用于保存 `*TrapContext`. 

`trap` 发生过程: 
1. 硬件设 `sepc`, `sstatus`, `scause`, `stval`, 跳转到 `stvec` 指向的 `__trap_entry`.
2. 交换 `sp`(用户栈) 和 `sscratch`.
3. 保存上下文: 寄存器, 用户态的 `csr(sepc, sstatus)`.
4. 此时 `sp`(`*TrapContext`) 已经保存到 `TrapContext`, 但是仍指向 `TrapContext`, 寄存器均已经保存, 可以随意使用.
5. 将 `kernel_stap`, `kernel_sp`, `trap_handle` 载入 寄存器.
6. 切换到 内核栈(`kernel_sp`)
7. 切换到内核空间, 并刷新缓存
8. 跳转到 `trap_handle`

#### 问题3. call指令的地址问题
`trap` 发生后, 我们保存完上下文, 依次切换栈, 内存空间后, 会调用 `trap_handle` 这个 `rust` 函数. 原本我们是通过 `call` 指令实现, 在链接时由编译器获取 `trap_handle` 的实际物理地址和 `call` 伪指令$^2$所在的地址, 计算 `offsize`, 通过跳转到 `pc` 加 `offsize` 的地址实现.
然而, 由于我们将 `Trap` 入口和返回的代码写到了单独的物理页上, 并映射到固定的 `TRAMPOLINE Page`, 而其他内核态的代码只发生恒等映射, 因此当虚拟内存启用后, 编译器计算出的物理 `offsize`, 并不是两者虚拟地址的 `offsize`.

**解决方案**是, 将 `trap_handle` 在内核空间的虚拟地址(恒等映射, 因此等于物理地址)也保存到内核栈上. 用 `jr xx` 进行函数调用.

### 内核线程
由于用户线程有自己的内存空间, 而内核线程与内核使用相同的空间, 即在 `trap` 发生时不需要切换页表入口, 同时也不需要处理跳板页的问题, 因此, 我们只需要采用与未使用内存空间时相似的 `trap` 策略:
1. 在内核栈底保存 `TrapContext` 上下文, `trap` 发生时, 先切换到内核栈, 保存现场, 跳转到内核的 `trap_handler` 函数.
2. 中断服务完成后, 将要恢复内核线程的执行流, 此时, 先设 `stvec` 到内核中断服务函数入口.
3. 向 `__kernel_trap_restroe` 传递 `TrapContext` 在栈中的位置, 恢复内核线程上下文, 切换回线程执行流.

## 注释
1. 内核栈底保存的是 `TrapContext`, 在 `Trap` 发生前, `kernel_sp` 指向该 `TrapContext`, 当跳转 `trap_handle` 后开始使用内核栈, `trap_handle`执行完之后, `kernel_sp` 一定会回到栈底, 指向 `TrapContext`. `TrapContext` 就用于保存这些固定信息.
2. `call rd, symbol` 伪指令对应的指令为: `auipc rd, offestHi, jalr rd, offsetLo(rd)`, 若 `call` 未指定 `rd`, 则使用 `ra`. 