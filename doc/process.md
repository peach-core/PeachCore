# 进程

## 进程树
遵循 linux 的规范, 采用进程树的方式管理进程, 1号进程是用户初始进程, 负责执行其他用户态进程. 除了1号进程(`init`)外, 所有用户态进程都有一个唯一的父进程. 所有进程都有子进程列表, 当一个 `进程A` 结束时, `A`的子进程被交由 `init` 祖先进程管理.

- 在 `windows` 下, 只有进程树的逻辑结构, 没有系统层的强制要求. 每个进程有一个唯一的 `Handle`, 任何一个进程 `A` 在获取了进程 `B` 的 `Handle` 时, 都被允许对 `B` 进程有完全管理权.

### 对应的数据结构
``` rust
pub struct TaskStructMutableInner {
    ...
    // process info.
    pub parent_process: Option<Weak<TaskStruct>>,
    pub children_process: Vec<Arc<TaskStruct>>,
    pub exit_code: i32,
}
```
用来管理父进程, 子进程组 和 退出状态(用于通知父进程).

## 进程创建
- [ ] 目前的fork实现, 将所有数据段都进行了拷贝, 无法实现进程间的全局数据共享.
### 系统调用  
`POSIX` 协议规定使用 `CLONE/FORK` 创建一个新的进程, 新创建的进程有自己的 `pid`, `kernel stack`, `user stack`, 而当前寄存器状态, 堆区, text段, bss段, data段, rodata段保持与父进程一致. 因此子进程也有自己的页表, 切换时也需要刷新页表缓存.

由于`fork` 会创建两个完全相同的进程, 但我们需要让子进程和父进程分别知道自己的身份, 这样才能执行正确的功能, 这一点是通过 `ra` 返回值完成的, `fork()` 对父进程的返回值为子进程的 `pid`, 对子进程的返回值为 `0`, 通过判断返回值, 进行分支, 即可知道接下来要执行的代码.

### 资源管理  
在进程退出后, 所有的用户态资源可以立即被释放, 而 `TCB`, 内核栈不能立即释放, 原因如下:  
1. 父进程需要通过 `pid` 寻找子进程用于获取执行状态, `exit_code` 等信息, 因此这些信息不能立即释放.
2. 进程 `x` 退出时, 发起 `exit` 系统调用, 此时 `cpu` 跑在进程 `x` 的内核栈上, 若立即释放会导致内存冲突.

因此资源回收需要分为两个阶段: 
1. 由进程主动释放用户态资源, 用户内存空间里的所有内存页均被释放. 将该进程的子进程交由 `init` 进程收容.
2. 由父进程回收, 包括 `pid`, 内核空间栈.

因此我们添加一个 `Zombie` 状态, 表示进程已经结束, 但是需要父进程来回收资源.

## 进程管理
### pid 管理
设计一个 `PidAllocator` 用于分配 `PidHandle`, `PidHandle` 通过 `RAII` 机制, 在生命周期结束时, 自动将 `pid` 归还给 `Allocator`.

### PCB 管理
设置 `Processor` 用于表示每个 `CPU`, `CPU` 会占用 `PCB` 的所有权. 剩下未被运行的 `PCB` 则放置在 `TASK_MANEGER` 中的 `ready_queue` 中(后续可以添加挂起队列等), 每次任务切换, 将旧进程换出 `CPU`, 放回 `TASK_MANEGER`, 从 `TASK_MANEGER` 获取新进程, 换入 `CPU` 执行.
